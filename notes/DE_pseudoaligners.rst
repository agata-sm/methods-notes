=================================================
Differential Expression Using Pseudoaligners
=================================================


This document presents opinions found in various sources on use of pseudoaligner output (salmon / kallisto) for differential gene expression.

Introduction
===============

Differential gene expression can be performed in two modes:

1. **gene**-centric: a "traditional" approach, read (pairs) are mapped to the genome reference, and are summarised at the **gene level** by counting reads mapped to features (individual exons being parts of a metafeature gene); count table consists of counts per gene: 1 mapped read (pair) - 1 count;
these count tables can be used for DGE by packages such as ``edgeR`` or ``DESeq2`` which use statistical framework based on assumptions of negative binomial distribution;

DGE (i.e., testing for changes in the overall transcriptional output of a gene) is typically performed by applying a count-based inference method from statistical packages such as edgeR or DESeq2 to gene counts obtained by read counting software such as featureCounts or HTSeq-count. This simple approach is prone to give erroneous results for genes with changes in relative isoform usage, especially when the differential transcripts greatly differ in length.


2. **transcript**-centric: 

2.a. counts are partitioned into different annotated transcripts rather than one genomic meta-feature gene; "partitioned" meaning count estimates are produced for each transcript; data can be summarised as **count estimates** which are conceptually similar to counts per transcript with built-in uncertainity estimate (because it is impossible to tell *with 100% certainty* from which transcript given count has originated) and **transcripts per million, TPM**, which can be used for *comparing the expression of different genes within a sample*;

In some workflows (e.g. tximport), the transcript count estimates are aggregated at the gene level and used for DE using standard count based methods at the gene level.

2.b. counts summarised per **exon** rather than per gene - used to perform differential exon usage (a proxy to the isoform profiling analysis or differential transcript usage DTU).


More on **TPM** (https://haroldpimentel.wordpress.com/2014/05/08/what-the-fpkm-a-review-rna-seq-expression-units/)::

TPM has a very nice interpretation when you’re looking at transcript abundances. As the name suggests, the interpretation is that if you were to sequence one million full length transcripts, TPM is the number of transcripts you would have seen of type *i*, given the abundances of the other transcripts in your sample. The last “given” part is important. The denominator is going to be different between experiments, and thus is also sample dependent which is why you cannot directly compare TPM between samples. While this is true, TPM is probably the most stable unit across experiments, though you still shouldn’t compare it across experiments.

TPM can be attributed to Bo Li et. al. in the original RSEM paper (https://academic.oup.com/bioinformatics/article/26/4/493/243395).




Kallisto
===========

**kallisto** is a program for quantifying abundances of transcripts from bulk and single-cell RNA-Seq data, or more generally of target sequences using high-throughput sequencing reads, based on the novel idea of pseudoalignment for rapidly determining the compatibility of reads with targets.  Pseudoalignment of reads preserves the key information needed for quantification.

output files:

**abundance.tsv** is a plaintext file of the abundance estimates. It does not contains bootstrap estimates. Please use the ``--plaintext`` mode to output plaintext abundance estimates. Alternatively, ``kallisto h5dump`` can be used to output an HDF5 file to plaintext. The first line contains a header for each column, including estimated counts, TPM, effective length.

**abundance.h5** is a HDF5 binary file containing run info, abundance esimates, bootstrap estimates, and transcript length information length. This file can be read in by sleuth.


For quantification purposes, kallisto should be run with bootstraps::

	-b, --bootstrap-samples=INT   Number of bootstrap samples (default: 0)


On bootstraps and kallisto output:

* the output in the .tsv file is the maximum likelihood estimate for the expression of transcripts. That process is completely deterministic (https://www.biostars.org/p/155032/);

* The bootstrap outputs are stored in the .h5 files, they are generated by resampling the original data and finding the expression for this new dataset. This is why you will get slightly different est_counts in the bootstraps, and the amount of variation gives you an indication of how reliable the initial point estimate is (https://www.biostars.org/p/155032/);

* The bootstrap has no influence whatsoever on the quantification step. The bootstrapping procedure will provide a measure of the accuracy of the quantification by random resampling with replacement. If you use the same seed and same number of bootstraps on the same dataset, the bootstraps estimates would be identical as well (https://www.biostars.org/p/155032/);


Useful links:

* https://pachterlab.github.io/kallisto/manual

* https://haroldpimentel.wordpress.com/2014/05/08/what-the-fpkm-a-review-rna-seq-expression-units/

* https://hbctraining.github.io/DGE_workshop_salmon/lessons/01_DGE_setup_and_overview.html



edgeR
=======

``edgeR`` contains a function to read in Kallisto and Salmon output::

	catchKallisto(paths, verbose = TRUE)
	catchSalmon(paths, verbose = TRUE)

Details:

These functions assume that kallisto or Salmon have been run to obtain **estimated transcript counts** for one or more RNA samples, and that **bootstrap samples have also been generated**. These functions catch the counts and use the bootstrap samples to estimate an over-dispersion coefficient for each transcript. Transcripts that overlap other transcripts and have greater read mapping uncertaintly will have greater over-dispersion coefficients.

The data is then ready for analysis in edgeR. 

Source: https://rdrr.io/bioc/edgeR/man/catchSalmon.html


tximport
=============


The recommended way to **input pseudoaligner output to edgeR** is via a package ``tximport`` (https://bioconductor.org/packages/release/bioc/html/tximport.html). The rationale and procedure are outlined in accompanying publication Soneson et al 2016 (https://f1000research.com/articles/4-1521/v2).


Take home messages from Sonseson et al, 2016:


* we provide an R package (tximport) to help users integrate transcript-level abundance estimates from common quantification pipelines into count-based statistical inference engines;

* gene-level estimation is considerably more accurate than transcript-level;

* regardless of the level at which abundance estimation is done, inferences at the gene level are appealing in terms of robustness, statistical performance and interpretation;

* taking advantage of transcript-level abundance estimates when defining or analyzing gene-level abundances leads to improved DGE results compared to simple counting for genes exhibiting DTU;

* On the six data sets studied here, simple counting with featureCounts led to very similar conclusions as estimated gene counts from Salmon, when combined with count-based statistical inference tools such as edgeR and DESeq2. Moreover, p-value distributions and mean-variance relationships were similar for actual and estimated counts.


import kallisto counts to tximport
----------------------------------------

https://bioconductor.org/packages/release/bioc/vignettes/tximport/inst/doc/tximport.html

kallisto ``abundance.h5`` files can be imported by setting type to "kallisto". Note that this requires that you have the Bioconductor package ``rhdf5`` installed. (Here we only demonstrate reading in transcript-level information.)

code::

	files <- file.path(dir, "kallisto_boot", samples$run, "abundance.h5")
	names(files) <- paste0("sample", 1:6)
	txi.kallisto <- tximport(files, type = "kallisto", txOut = TRUE)
	head(txi.kallisto$counts)

data::

	##                   sample1 sample2 sample3 sample4 sample5 sample6
	## ENST00000448914.1       0       0       0       0       0       0
	## ENST00000631435.1       0       0       0       0       0       0
	## ENST00000632684.1       0       0       0       0       0       0
	## ENST00000434970.2       0       0       0       0       0       0
	## ENST00000415118.1       0       0       0       0       0       0
	## ENST00000633010.1       0       0       0       0       0       0


**with inferential replicates**

Because the kallisto_boot directory also has inferential replicate information, it was imported as well::

	names(txi.kallisto)

	## [1] "abundance"           "counts"              "infReps"            
	## [4] "length"              "countsFromAbundance"

	names(txi.kallisto$infReps)

	## [1] "sample1" "sample2" "sample3" "sample4" "sample5" "sample6"

	dim(txi.kallisto$infReps$sample1)

	## [1] 178136      5


**kallisto with TSV files**

kallisto abundance.tsv files can be imported as well, but this is typically slower than the approach above. Note that we add an additional argument in this code chunk, ignoreAfterBar=TRUE. This is because the Gencode transcripts have names like “ENST00000456328.2|ENSG00000223972.5|…”, though our tx2gene table only includes the first “ENST” identifier. We therefore want to split the incoming quantification matrix rownames at the first bar “|”, and only use this as an identifier. We didn’t use this option earlier with Salmon, because we used the argument --gencode when running Salmon, which itself does the splitting upstream of tximport. Note that ignoreTxVersion and ignoreAfterBar are only to facilitating the summarization to gene level.

code::

	files <- file.path(dir, "kallisto", samples$run, "abundance.tsv.gz")
	names(files) <- paste0("sample", 1:6)
	txi.kallisto.tsv <- tximport(files, type = "kallisto", tx2gene = tx2gene, ignoreAfterBar = TRUE)
	head(txi.kallisto.tsv$counts)

data::

	##                       sample1   sample2    sample3    sample4    sample5
	## ENSG00000000003.14    2.59745    2.0000   27.15883    8.40623    5.06463
	## ENSG00000000005.5     0.00000    0.0000    0.00000    0.00000    0.00000
	## ENSG00000000419.12 1057.00040 1338.0006 1453.00134 1289.00080  921.00030
	## ENSG00000000457.13  462.52870  495.4173  564.18460  385.98791  532.84843
	## ENSG00000000460.16  630.39723  418.5453 1166.26643  611.51433  915.49327
	## ENSG00000000938.12 2618.00130 3697.9998 3110.00650 2691.99670 1896.99980
	##                       sample6
	## ENSG00000000003.14    5.74125
	## ENSG00000000005.5     0.00000
	## ENSG00000000419.12 1332.00240
	## ENSG00000000457.13  543.53370
	## ENSG00000000460.16  636.25649
	## ENSG00000000938.12 1909.99870



nf-core RNA-seq pipeline
===========================

* you can choose to pseudoalign and quantify your data with Salmon or Kallisto by providing the --pseudo_aligner parameter;

* The tximport package is used in this pipeline to summarise the results generated by Salmon or Kallisto into matrices for use with downstream differential analysis packages. We use tximport with different options to summarize count and TPM quantifications at the gene- and transcript-level. Please see #499 for discussion and links regarding which counts are suitable for different types of analysis.


According to the txtimport documentation you can do one of the following:

* Use bias corrected counts with an offset: import all the salmon files with tximport and then use DESeq2 with dds <- DESeqDataSetFromTximport(txi, sampleTable, ~condition) to correct for changes to the average transcript length across samples.
    
* Use bias corrected counts without an offset: load and use salmon.merged.gene_counts_length_scaled.tsv or salmon.merged.gene_counts_scaled.tsv directly as you would with a regular counts matrix.
    
* Use bias uncorrected counts: load and use the txi$counts matrix (or salmon.merged.gene_counts.tsv) with DESeq2. This does not correct for potential differential isoform usage. Alternatively, if you have 3’ tagged RNA-seq data this is the most suitable method.


summary of discussion in issue #499 (https://github.com/nf-core/rnaseq/issues/499):

* Do not manually pass the original gene-level counts to downstream methods without an offset. The only case where this would make sense is if there is no length bias to the counts, as happens in 3’ tagged RNA-seq data (see section below). The original gene-level counts are in txi$counts when tximport was run with countsFromAbundance="no". This is simply passing the summed estimated transcript counts, and does not correct for potential differential isoform usage (the offset), which is the point of the tximport methods (Soneson, Love, and Robinson 2015) for gene-level analysis.

* Code aside - the key thing to be noted in the nf-core/rnaseq documentation is that if salmon is used, the counts have to be non-normalized before DESeq and the above code does that.


* Mike Love::

	Just to say, I typically use:

	    counts + offset for use with DESeq(). This is what you get with basic calls of tximport, DESeqDataSetFromTximport, DESeq without additional arguments.
	    counts alone with countsFromAbundance="lengthScaledTPM" if I am prevented from passing an offset matrix for some reason. Maybe if you want a single matrix for use with DESeq2, edgeR, limma then this is a good compromise. You can still use DESeqDataSetFromTximport, it will figure out to not build an offset.
	    scaledTPM or dtuScaledTPM for DTU analysis.



https://github.com/COMBINE-lab/salmon/issues/581

preferred way to import counts to DESeq2 (Mike Love)::

	# DESeqDataSetFromTximport
	dds <- DESeqDataSetFromTximport(txi, sampleTable, ~condition)

*  I only prefer people use ...Tximport() only because we had some people using txi$counts alone and not using the countsFromAbundance argument, and then calling that the "tximport" method, which was making others confused. That's all.



If and how to use Kallisto output in edgeR
================================================

This subsection lists contents of various discussions on online fora (BioStars, Bioconductor). Sometimes the questions and answers are edited for clarity.


Can Kallisto be followed by DESeq, EdgeR or Cuffdiff?
---------------------------------------------------------

https://www.biostars.org/p/157240/

https://www.biostars.org/p/143458/#157303


Q: ``Can kallisto be followed by downstream analysis tools other than Sleuth?``

Rob Patro (salmon)::

	Kallisto is built with Sleuth in mind, and so other DE tools won't be able to natively take advantage of e.g. the bootstrapped uncertainty estimates produced by Kallisto (why prefer Sleuth over using estimated counts with tools like DESeq or EdgeR: the modeling and distributional assumptions are different).




Transcript to gene level count for DEseq(2) use- Salmon/Sailfish/Kallisto etc.
------------------------------------------------------------------------------------

This is discussion with contributions from many hosehold names in the filed of RNA-seq statistics:

https://www.biostars.org/p/143458/

Michael Love (DESeq2)::

	We use the requirement for discrete counts as input so that users don't try to input normalized counts (for example dividing out library size), which would be inappropriate and my main concern here. If you can input a matrix which is close to a count of fragments which uniquely align to each gene (so no double counting of fragments from the different transcripts of a gene

	We now have a suggested workflow for importing transcript estimates from Sailfish, Salmon, or kallisto and summarizing to the gene-level for use with count-based tools like edgeR, DESeq2, limma-voom. The package is on Bioconductor and has a vignette with example code: http://bioconductor.org/packages/tximport


Lior Pachter (kallisto)::

    kallisto produces estimates of transcript level counts, and therefore to obtain an estimate of the number of reads from a gene the correct thing to do is to sum the estimated counts from the constituent transcripts of that gene. Of note in the language above is the word "estimate", which is necessary because in many cases reads cannot be mapped uniquely to genes. However insofar as obtaining a good estimate, the approach of kallisto (and before it Cufflinks, RSEM, eXpress and other "transcript level quantification tools") is superior to naïve "counting" approaches for estimating the number of reads originating from a gene. This point has been argued in many papers; among my own papers it is most clearly explained and demonstrated in Trapnell et al. 2013.

    Although estimated counts for a gene can be obtained by summing the estimated counts of the constituent transcripts from tools such as kallisto, and the resulting numbers can be rounded to produce integers that are of the correct format for tools such as DESeq, the numbers produced by such an approach do not satisfy the distributional assumptions made in DESeq and related tools. For example, in DESeq2, counts are modeled "as following a negative binomial distribution". This assumption is not valid when summing estimated counts of transcripts to obtain gene level counts, hence the justified concern of Michael Love that plugging in sums of estimated transcript counts could be problematic for DESeq2. In fact, even the estimated transcript counts themselves are not negative binomial distributed, and therefore also those are not appropriate for plugging into DESeq2. His concern is equally valid with many other "count based" differential expression tools.

    Fortunately there is a solution for performing valid statistical testing of differential abundance of individual transcripts, namely the method implemented in sleuth. The approach is described here. To test for differential abundance of genes, one must first address the question of what that means. E.g. is a gene differential if at least one isoform is? or if all the isoforms are? The tests of sleuth are performed at the granularity of transcripts, allowing for downstream analysis that can capture the varied questions that might make biological sense in specific contexts.

	In summary, please do not plug in rounded estimates of gene counts from kallisto into DESeq2 and other tools. While it is technically possible, it is not statistically advisable. Instead, you should use tools that make valid distributional assumptions about the estimates.

Mark Robinson (edgeR, tximport)::

    I think we all agree; proper portioning of reads to transcripts (assuming the annotation is reasonably accurate) is better than raw gene-level union counting. The claim of "superior" seems to be mostly in hypothetical/simulation situations, although I've now experienced one convincing example (unpublished data) where it makes a difference. Across a small number of datasets, we found very little difference between proper and raw counting (see Figure 4 of http://goo.gl/ySQTlu), but I'd be glad if someone can point me to good examples where it makes a difference.

    Transcript-level counts are still count-like and from what we can tell, applying edgeR/DESeq2 to transcript-level counts (or transcript-level estimates properly aggregrated to the gene-level) is ok. There may be room for improvement, but the mean-variance or dispersion-mean relationships are basically the same, P-value distributions look healthy and I don't see much evidence for the "assumption is not valid" claim above. Would be happy to see this evidence if there is some. I see it as a "all models are wrong, but some are useful" situation and vanilla NB is still useful here. More discussion @F1000: http://f1000research.com/articles/4-1521/v1

    I agree that sleuth is a valid solution. The main potential disadvantage that I can see is that it models the log of the expression (this introduces a different mean-variance relationship that needs to be modeled) and since expression is count-like, I would prefer to keep it in a count model. We and others have observed that this log-transform approach (e.g., limma-voom) loses a bit of sensitivity (e.g., http://nar.oxfordjournals.org/content/42/11/e91/F5.expansion.html); certainly not a crisis, but I think you can do better. As Lior mentions, it's important to define the question. In general, we favour differential expression analyses at the gene-level and observe that DE "at granularity of transcripts" often gets cast back to the gene-level, so you might as well operate at the gene-level from the outset. Of course, some situations do beg for transcript-level analyses. More discussion in our paper: http://f1000research.com/articles/4-1521/v1

	In summary, feel free to plug in proper transcript- or gene-level count-like estimates into edgeR/DESeq2.



Use of pseudoalignment estimated counts as input to edgeR and Limma-Voom
---------------------------------------------------------------------------

https://support.bioconductor.org/p/117739/


Gordon Smyth (edgeR, limma)::

	I'll tell you what I use. I use:

	    Rsubread::align + featureCounts + limma or edgeR-QL for gene level expression analyses

	    Rsubread::subjunc + featureCounts + limma or edgeR for differential splicing analyses

	    Salmon (with bootstrapping) + edgeR::catchSalmon for transcript level expression analysis.

	The short answer to your question is that getting genewise counts from kallisto is ok as input to either limma and edgeR. Of course you should work from the counts and not the TPMs. Either the tximport genewise pipeline or else just adding up counts over transcript for each gene are both ok from this point of view.

	In fact, getting total transcript counts from kallisto is in principle the same as running featureCounts on the same transcriptome annotation except that kallisto is restricted to perfect match alignments so featureCounts should manage to count more reads.

	There's a much longer answer, but I don't really want to write at length here or now. I will say that kallisto makes too many assumptions and approximations for my taste and I personally wouldn't hesitate to use Rsubread instead. Just to name one issue of many, more than 10% of Ensembl transcriptome annotation is made up of duplicates, i.e., the exact same transcript sequence but with multiple entries under different names, and kallisto does no checking of this. Genewise inference is robust whereas transcript-level inference is inherently noisy, so using transcripts as an intermediary to get genewise counts seems a peculiar choice to me.

	Responding to your comment about Soneson et al (2016), they were not actually able to show any improvement for tximport over featureCounts for any real dataset. Of course their main point is true. If a gene has a two transcripts of very different lengths, and the short transcript is expressed more highly than the long, and the two transcripts are both DE but in opposite directions, then it is possible for total genewise count and total gene expression (sum of transcript expressions) to show fold changes in opposite directions. My understanding is that the tximport refinement is intended to get the genewise counts to better align with sum of transcript expression. This scenario isn't very common in practice but if you run a simulation for which this scenario is the norm then of course you can show a difference. My view is that the tximport refinement isn't a complete solution, as it would be better to detect the discordant DE, and this refinement is in any case dwarfed by other issues with kallisto and imperfect annotation.


raf4::

	Thanks. I know that procedure. Gordon has written :""In my opinion, there is no good way to do a DE analysis of RNA-seq data starting from the TPM values. TPMs just throw away too much information about the original count sizes."

	I am asking if pseudoalignment algorithms also lose that information.

reply::

	For DESeq2 and edgeR, the procedure described in the tximport vignette doesn't suffer from this problem, because it converts the TPMs and average gene lengths into counts and offsets. This means you are getting the gene counts that were inferred by Kallisto, even if they might be back-calculated from TPMs.


Differential expression analysis starting from TPM data
------------------------------------------------------------

https://support.bioconductor.org/p/98820/

Gordon Smyth::

	In my opinion, there is no good way to do a DE analysis of RNA-seq data starting from the TPM values. TPMs just throw away too much information about the original count sizes. Sorry, but I'm not willing to make any recommendations, except to dissuade people from thinking that TPMs are an adequate summary of an RNA-seq experiment.

	Note that it is not possible to create a DGEList object or CPM values from TPMs, so trying to use code designed for these sort of objects will be counter-productive.

	I see that some people in the literature have done limma analyses of the log(TPM+1) values and, horrible though that is, I can't actually think of anything better, given TPMs and existing software. One could make this a little better by using eBayes with trend=TRUE and by using arrayWeights() to try to partially recover the library sizes. Please do not take that as a recommendation though!



------

(by Agata Smialowska 16 November 2023)

